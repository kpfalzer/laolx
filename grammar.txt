//add decomposition declaration:
// auto& [l1, l2] = expr_returns_2_elements

SourceFile: IncludeStatement* (Declaration | Statement)* EOF

IncludeStatement: K_INCLUDE StringList

String: SQSTRING | DQSTRING

StringList: String (COMMA String)+

// extern linkage declarations do not have bodies, etc.
Linkage: K_EXTERN String

Declaration: 
	Linkage? ClassDeclaration 
| 	Linkage? InterfaceDeclaration
| 	Linkage? VariableDeclaration 
| 	Linkage? MethodDeclaration 
| 	TypedefDeclaration 
| 	NamespaceDeclaration

// see std::variant (c++17)
UnionType: S_LPAREN Type (S_OR Type)* S_RPAREN

Access: K_PUBLIC | K_PROTECTED | K_PRIVATE

/**
//example of class:
// p1 and p2 are readonly attributes
class foo<T1,T2>(int @p1, string @p2) : public C1, C2(a:p1), I(a:p1,b:p2) {
	int @a = 14;	// a is an attribute
	T v = 17;       // const T v = 17;
}
//TODO: eventually add multiple decl
class A(int p1, p1; T p2, p3; T2 p2, T3 p4) {}
**/

ClassDeclaration: 
	K_CLASS IDENT TemplateParameterList? 
  		MethodParametersDeclaration?
  		BaseClause?
  		LCURLY ClassBody? RCURLY

TemplateParameterList:
	S_LT TemplateParameter (COMMA TemplateParameter)* S_GT

TemplateParameter: IDENT (S_EQ InitializerClause)?

MethodParametersDeclaration:
	S_LPAREN MethodParameterList? S_RPAREN

MethodParameterList:
	MethodParameter (COMMA MethodParameter)*

MethodParameter:
	Access? Mutability? TypeName VarOrAttrName (S_EQ InitializerClause)?

Mutability: K_CONST

VarName: IDENT
VarOrAttrName: VarName | ATTR_DECL | ATTR_DECL_RO | ATTR_DECL_RW

// see structured binding: 
// http://en.cppreference.com/w/cpp/language/structured_binding
VariableDeclaration:
	Mutability? K_STATIC? TypeName? VarName (S_EQ InitializerClause)? 

BaseClause:
	S_COLON BaseSpecifierList

BaseSpecifierList:
	BaseSpecifier (COMMA BaseSpecifier)*

BaseSpecifier:
	Access? BaseTypeSpecifier BaseInitializerSpecifier?	

BaseInitializerSpecifier:
	S_LPAREN BaseInitializerList S_RPAREN

BaseInitializerList:
	BaseInitializer (COMMA BaseInitializer)*

//named association
BaseInitializer:
	(IDENT S_COLON)? InitializerClause
	
BaseTypeSpecifier:
	S_COLON2? NestedNameSpecifier? BaseName

// class | interface name
BaseName: IDENT | SimpleTemplateId

InitializerClause: AssignmentExpression | BracedInitList

BracedInitList: 
	S_LCURLY InitializerList COMMA? S_RCURLY
|	S_LCURLY S_RCURLY

// NOTE: see:
// http://en.cppreference.com/w/cpp/language/list_initialization.html
InitializerList:
	InitializerClause (S_COMMA InitializerClause)

AssignmentExpression: ConditionalExpression

ConditionalExpression:
	ExpressionEle (S_QMARK Expression S_COLON Expression)?

// NOTE: Semantics of comma operator here are not same as c++/default.
// Here, we are like ruby and create collection.
// (c++: http://en.cppreference.com/w/cpp/language/operator_other)
Expression: AssignmentExpression //kiss: (S_COMMA AssignmentExpression)*

// NOTE: ExpressionEle is simplified logical-or-expression of c++ grammar
ExpressionEle:
	UnaryExpression (BinaryOp ExpressionEle)*

BinaryOp: //see code directly

UnaryExpression:
	PostfixExpression
|	(S_PLUS2 | S_MINUS2) UnaryExpression
|	UnaryOperator UnaryExpression

UnaryOperator: S_PLUS | S_MINUS | S_EXCLAMATION | S_TILDE

// NOTE: removed left recursion: 
// A: A x | y
// by
// A: y A_X?
// A_X: x A_X?
//
PostfixExpression: PostfixExpressionY PostfixExpressionX?

PostfixExpressionY:
	PrimaryExpression
|	SimpleTypeSpecifier S_LPAREN ExpressionList? S_RPAREN
|	SimpleTypeSpecifier BracedInitList

PostfixExpressionX
	S_LBRACK Expression S_RBRACK PostfixExpressionX?
|	S_LBRACK BracedInitList? S_RBRACK PostfixExpressionX?
|	S_LPAREN ExpressionList? S_RPAREN PostfixExpressionX?
|	DOT K_TEMPLATE? IdExpression PostfixExpressionX?
|	(S_PLUS2 | S_MINUS2) PostfixExpressionX?

PrimaryExpression:
	Literal
|	K_THIS
|	S_LPAREN Expression S_RPAREN
|	IdExpression
|	LambdaExpression

Literal:
	SYMBOL
|	INT
|	DOUBLE
|	String
|	REGEXP
|	Words
|	Symbols
|	K_NIL
|	Bool

Bool: K_TRUE | K_FALSE

Words: S_WORDS IDENT* S_RCURLY

Symbols: S_SYMBOLS IDENT* S_RCURLY

ExpressionList: InitializerList

// todo: replace Type, SimpleType above???
SimpleTypeSpecifier:
	S_COLON2? NestedNameSpecifier? TypeName
|	K_INT
|	K_FLOAT
|	K_STRING

IdExpression:
	UnqualifiedId
|	QualifiedId

UnqualifiedId:
	IDENT
|	OperatorFunctionId
|	TemplateId

QualifiedId:
	S_COLON2? NestedNameSpecifier K_TEMPLATE? UnqualifiedId
|	S_COLON2 IDENT
|	S_COLON2 OperatorFunctionId
|	S_COLON2 TemplateId

NestedNameSpecifier: NestedNameSpecifierY NestedNameSpecifierX?

NestedNameSpecifierY:
	TypeName S_COLON2
|	NamespaceName S_COLON2

NestedNameSpecifierX:
	IDENT S_COLON2 NestedNameSpecifierX?
|	K_TEMPLATE? SimpleTemplateId S_COLON2 NestedNameSpecifierX?

NamespaceName: IDENT
	
TypeName: ClassName | TypedefName | SimpleTemplateId

ClassName: IDENT | SimpleTemplateId

TypedefName: IDENT

SimpleTemplateId: IDENT S_LT TemplateArgumentList? S_GT

TemplateId:
	SimpleTemplateId
|	OperatorFunctionId S_LT TemplateArgumentList? S_GT

TemplateArgumentList:
	TemplateArgument (S_COMMA TemplateArgument)*
	
TemplateArgument:
	ConstantExpression
|	IdExpression

OperatorFunctionId:
	K_OPERATOR OverloadableOperator

+ how to specify visibility
+ initial statement/decls are part of default constructor
+ method return values?
+ other attributes
ClassBody:
	MethodBody MethodDeclaration*

MethodBody: MethodBodyItem*

MethodBodyItem:
	TypedefDeclaration
|	MemberVariableDeclaration
|	Statement

MemberVariableDeclaration:
	Access? Mutability? K_STATIC? TypeName? VarOrAttrName 
		(S_EQ InitializerClause)? 

MethodDeclaration:
	Access? Mutability? K_STATIC? 
		(	K_DEF IDENT
		|	K_OPERATOR OverloadableOperator
		)
		MethodParametersDeclaration?
		ReturnSpecifier?
		S_LCURLY MethodBody S_RCURLY

ReturnSpecifier: 
	S_EQGT SimpleTypeSpecifier
|	S_EQGT S_LPAREN SimpleTypeSpecifierList S_RPAREN

